declare module "types" {
    import { TemplateResult } from 'lit-html';
    export type Element = HTMLElement | string | ShadowRoot;
    export type VNode = {
        tag?: string | Function;
        type?: string | Function;
        props?: {};
        children?: Array<VNode | string>;
    };
    export type VNodeExt = false | string | VNode | HTMLElement | SVGAElement | TemplateResult;
    export type VDOM = VNodeExt | Array<VNodeExt | string>;
    export type View<T> = (state: T) => VDOM | void;
    export type Action<T> = (state: T, ...p: any[]) => T | Promise<T> | void;
    export type ActionDef<T, E> = (readonly [E, Action<T>, {}?]);
    export type Update<T, E = string> = ActionDef<T, E>[] | {
        [name: string]: Action<T> | {}[];
    } | (E | Action<T> | {})[];
    export type ActionOptions = {
        render?: boolean;
        history?: any;
        global?: boolean;
        callback?: (state: any) => void;
    };
    export type EventOptions = {
        once?: boolean;
        transition?: boolean;
        delay?: number;
    } | any;
    export type MountOptions = {
        render?: boolean;
        history?: any;
        global_event?: boolean;
        route?: string;
        transition?: boolean;
    };
    export type AppStartOptions<T> = {
        render?: boolean;
        history?: any;
        transition?: boolean;
        route?: string;
        rendered?: (state: T) => void;
        mounted?: (props: any, children: any, state: T) => T;
    };
    export type CustomElementOptions = {
        render?: boolean;
        shadow?: boolean;
        history?: boolean;
        global_event?: boolean;
        observedAttributes?: string[];
    };
    export type Events = Record<string, Array<{
        fn: Function;
        options: EventOptions;
    }>>;
}
declare module "web-component" {
    export type CustomElementOptions = {
        render?: boolean;
        shadow?: boolean;
        history?: boolean;
        global_event?: boolean;
        observedAttributes?: string[];
    };
    export const customElement: (componentClass: any, options?: CustomElementOptions) => {
        new (): {
            _shadowRoot: any;
            _component: any;
            _attrMap: (arg0: string) => string;
            on: any;
            run: any;
            readonly component: any;
            readonly state: any;
            connectedCallback(): void;
            disconnectedCallback(): void;
            attributeChangedCallback(name: string, oldValue: unknown, value: unknown): void;
            accessKey: string;
            readonly accessKeyLabel: string;
            autocapitalize: string;
            dir: string;
            draggable: boolean;
            hidden: boolean;
            inert: boolean;
            innerText: string;
            lang: string;
            readonly offsetHeight: number;
            readonly offsetLeft: number;
            readonly offsetParent: Element;
            readonly offsetTop: number;
            readonly offsetWidth: number;
            outerText: string;
            spellcheck: boolean;
            title: string;
            translate: boolean;
            attachInternals(): ElementInternals;
            click(): void;
            addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
            addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
            removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
            removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
            readonly attributes: NamedNodeMap;
            readonly classList: DOMTokenList;
            className: string;
            readonly clientHeight: number;
            readonly clientLeft: number;
            readonly clientTop: number;
            readonly clientWidth: number;
            id: string;
            readonly localName: string;
            readonly namespaceURI: string;
            onfullscreenchange: (this: Element, ev: Event) => any;
            onfullscreenerror: (this: Element, ev: Event) => any;
            outerHTML: string;
            readonly ownerDocument: Document;
            readonly part: DOMTokenList;
            readonly prefix: string;
            readonly scrollHeight: number;
            scrollLeft: number;
            scrollTop: number;
            readonly scrollWidth: number;
            readonly shadowRoot: ShadowRoot;
            slot: string;
            readonly tagName: string;
            attachShadow(init: ShadowRootInit): ShadowRoot;
            closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
            closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
            closest<E extends Element = Element>(selectors: string): E;
            getAttribute(qualifiedName: string): string;
            getAttributeNS(namespace: string, localName: string): string;
            getAttributeNames(): string[];
            getAttributeNode(qualifiedName: string): Attr;
            getAttributeNodeNS(namespace: string, localName: string): Attr;
            getBoundingClientRect(): DOMRect;
            getClientRects(): DOMRectList;
            getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
            getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
            getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
            getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
            getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
            hasAttribute(qualifiedName: string): boolean;
            hasAttributeNS(namespace: string, localName: string): boolean;
            hasAttributes(): boolean;
            hasPointerCapture(pointerId: number): boolean;
            insertAdjacentElement(where: InsertPosition, element: Element): Element;
            insertAdjacentHTML(position: InsertPosition, text: string): void;
            insertAdjacentText(where: InsertPosition, data: string): void;
            matches(selectors: string): boolean;
            releasePointerCapture(pointerId: number): void;
            removeAttribute(qualifiedName: string): void;
            removeAttributeNS(namespace: string, localName: string): void;
            removeAttributeNode(attr: Attr): Attr;
            requestFullscreen(options?: FullscreenOptions): Promise<void>;
            requestPointerLock(): void;
            scroll(options?: ScrollToOptions): void;
            scroll(x: number, y: number): void;
            scrollBy(options?: ScrollToOptions): void;
            scrollBy(x: number, y: number): void;
            scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
            scrollTo(options?: ScrollToOptions): void;
            scrollTo(x: number, y: number): void;
            setAttribute(qualifiedName: string, value: string): void;
            setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
            setAttributeNode(attr: Attr): Attr;
            setAttributeNodeNS(attr: Attr): Attr;
            setPointerCapture(pointerId: number): void;
            toggleAttribute(qualifiedName: string, force?: boolean): boolean;
            webkitMatchesSelector(selectors: string): boolean;
            readonly baseURI: string;
            readonly childNodes: NodeListOf<ChildNode>;
            readonly firstChild: ChildNode;
            readonly isConnected: boolean;
            readonly lastChild: ChildNode;
            readonly nextSibling: ChildNode;
            readonly nodeName: string;
            readonly nodeType: number;
            nodeValue: string;
            readonly parentElement: HTMLElement;
            readonly parentNode: ParentNode;
            readonly previousSibling: ChildNode;
            textContent: string;
            appendChild<T extends Node>(node: T): T;
            cloneNode(deep?: boolean): Node;
            compareDocumentPosition(other: Node): number;
            contains(other: Node): boolean;
            getRootNode(options?: GetRootNodeOptions): Node;
            hasChildNodes(): boolean;
            insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
            isDefaultNamespace(namespace: string): boolean;
            isEqualNode(otherNode: Node): boolean;
            isSameNode(otherNode: Node): boolean;
            lookupNamespaceURI(prefix: string): string;
            lookupPrefix(namespace: string): string;
            normalize(): void;
            removeChild<T_2 extends Node>(child: T_2): T_2;
            replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
            readonly ATTRIBUTE_NODE: number;
            readonly CDATA_SECTION_NODE: number;
            readonly COMMENT_NODE: number;
            readonly DOCUMENT_FRAGMENT_NODE: number;
            readonly DOCUMENT_NODE: number;
            readonly DOCUMENT_POSITION_CONTAINED_BY: number;
            readonly DOCUMENT_POSITION_CONTAINS: number;
            readonly DOCUMENT_POSITION_DISCONNECTED: number;
            readonly DOCUMENT_POSITION_FOLLOWING: number;
            readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
            readonly DOCUMENT_POSITION_PRECEDING: number;
            readonly DOCUMENT_TYPE_NODE: number;
            readonly ELEMENT_NODE: number;
            readonly ENTITY_NODE: number;
            readonly ENTITY_REFERENCE_NODE: number;
            readonly NOTATION_NODE: number;
            readonly PROCESSING_INSTRUCTION_NODE: number;
            readonly TEXT_NODE: number;
            dispatchEvent(event: Event): boolean;
            ariaAtomic: string;
            ariaAutoComplete: string;
            ariaBusy: string;
            ariaChecked: string;
            ariaColCount: string;
            ariaColIndex: string;
            ariaColIndexText: string;
            ariaColSpan: string;
            ariaCurrent: string;
            ariaDisabled: string;
            ariaExpanded: string;
            ariaHasPopup: string;
            ariaHidden: string;
            ariaInvalid: string;
            ariaKeyShortcuts: string;
            ariaLabel: string;
            ariaLevel: string;
            ariaLive: string;
            ariaModal: string;
            ariaMultiLine: string;
            ariaMultiSelectable: string;
            ariaOrientation: string;
            ariaPlaceholder: string;
            ariaPosInSet: string;
            ariaPressed: string;
            ariaReadOnly: string;
            ariaRequired: string;
            ariaRoleDescription: string;
            ariaRowCount: string;
            ariaRowIndex: string;
            ariaRowIndexText: string;
            ariaRowSpan: string;
            ariaSelected: string;
            ariaSetSize: string;
            ariaSort: string;
            ariaValueMax: string;
            ariaValueMin: string;
            ariaValueNow: string;
            ariaValueText: string;
            role: string;
            animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
            getAnimations(options?: GetAnimationsOptions): Animation[];
            after(...nodes: (string | Node)[]): void;
            before(...nodes: (string | Node)[]): void;
            remove(): void;
            replaceWith(...nodes: (string | Node)[]): void;
            innerHTML: string;
            readonly nextElementSibling: Element;
            readonly previousElementSibling: Element;
            readonly childElementCount: number;
            readonly children: HTMLCollection;
            readonly firstElementChild: Element;
            readonly lastElementChild: Element;
            append(...nodes: (string | Node)[]): void;
            prepend(...nodes: (string | Node)[]): void;
            querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
            querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
            querySelector<E_1 extends Element = Element>(selectors: string): E_1;
            querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
            querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
            querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
            replaceChildren(...nodes: (string | Node)[]): void;
            readonly assignedSlot: HTMLSlotElement;
            oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
            oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
            onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
            readonly style: CSSStyleDeclaration;
            contentEditable: string;
            enterKeyHint: string;
            inputMode: string;
            readonly isContentEditable: boolean;
            onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
            onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
            onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
            onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
            onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
            onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            onbeforeinput: (this: GlobalEventHandlers, ev: InputEvent) => any;
            onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
            oncancel: (this: GlobalEventHandlers, ev: Event) => any;
            oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
            oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
            onchange: (this: GlobalEventHandlers, ev: Event) => any;
            onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            onclose: (this: GlobalEventHandlers, ev: Event) => any;
            oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
            ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
            ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
            ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
            ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
            ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
            ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
            ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
            ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
            onemptied: (this: GlobalEventHandlers, ev: Event) => any;
            onended: (this: GlobalEventHandlers, ev: Event) => any;
            onerror: OnErrorEventHandlerNonNull;
            onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
            onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
            ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
            oninput: (this: GlobalEventHandlers, ev: Event) => any;
            oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
            onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
            onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
            onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
            onload: (this: GlobalEventHandlers, ev: Event) => any;
            onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
            onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
            onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
            onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
            onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
            onpause: (this: GlobalEventHandlers, ev: Event) => any;
            onplay: (this: GlobalEventHandlers, ev: Event) => any;
            onplaying: (this: GlobalEventHandlers, ev: Event) => any;
            onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
            onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
            onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
            onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
            onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
            onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
            onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
            onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
            onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
            onratechange: (this: GlobalEventHandlers, ev: Event) => any;
            onreset: (this: GlobalEventHandlers, ev: Event) => any;
            onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
            onscroll: (this: GlobalEventHandlers, ev: Event) => any;
            onsecuritypolicyviolation: (this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any;
            onseeked: (this: GlobalEventHandlers, ev: Event) => any;
            onseeking: (this: GlobalEventHandlers, ev: Event) => any;
            onselect: (this: GlobalEventHandlers, ev: Event) => any;
            onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
            onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
            onslotchange: (this: GlobalEventHandlers, ev: Event) => any;
            onstalled: (this: GlobalEventHandlers, ev: Event) => any;
            onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
            onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
            ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
            ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
            ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
            ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
            ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
            ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
            ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
            ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
            ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
            ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
            onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
            onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
            onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
            onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
            onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
            onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
            onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
            autofocus: boolean;
            readonly dataset: DOMStringMap;
            nonce?: string;
            tabIndex: number;
            blur(): void;
            focus(options?: FocusOptions): void;
        };
        readonly observedAttributes: string[];
    };
    const _default: (name: string, componentClass: any, options?: CustomElementOptions) => void;
    export default _default;
}
declare module "decorator" {
    import { CustomElementOptions } from "web-component";
    export const Reflect: {
        meta: WeakMap<object, any>;
        defineMetadata(metadataKey: any, metadataValue: any, target: any): void;
        getMetadataKeys(target: any): string[];
        getMetadata(metadataKey: any, target: any): any;
    };
    export function update<E = string>(events?: E, options?: any): Function;
    export function on<E = string>(events?: E, options?: any): Function;
    export function customElement(name: string, options?: CustomElementOptions): Function;
}
declare module "directive" {
    const directive: (vdom: any, component: any) => any;
    export default directive;
}
declare module "component" {
    import { View, Update, Action, ActionOptions, MountOptions, EventOptions } from "types";
    export class Component<T = any, E = any> {
        state?: T;
        view?: View<T>;
        update?: Update<T, E>;
        protected options?: MountOptions;
        static __isAppRunComponent: boolean;
        private _app;
        private _actions;
        private _global_events;
        private _state;
        private _history;
        private _history_idx;
        private enable_history;
        private global_event;
        element: any;
        rendered: (state: T) => void;
        mounted: (props: any, children: any[], state: T) => T | void;
        unload: (state: T) => void;
        private tracking_id;
        private observer;
        renderState(state: T, vdom?: any): void;
        setState(state: T | Promise<T>, options?: ActionOptions & EventOptions): void;
        private _history_prev;
        private _history_next;
        constructor(state?: T, view?: View<T>, update?: Update<T, E>, options?: MountOptions);
        start: (element?: any, options?: MountOptions) => Component<T, E>;
        mount(element?: any, options?: MountOptions): Component<T, E>;
        is_global_event(name: string): boolean;
        add_action(name: string, action: Action<T>, options?: ActionOptions): void;
        add_actions(): void;
        run(event: E, ...args: any[]): any;
        on(event: E, fn: (...args: any[]) => void, options?: any): void;
        runAsync(event: E, ...args: any[]): Promise<any[]>;
        query(event: E, ...args: any[]): Promise<any[]>;
        unmount(): void;
    }
}
declare module "app" {
    import { Events, EventOptions, AppStartOptions, VDOM, View, Update, CustomElementOptions } from "types";
    import { Component } from "component";
    export class App {
        _events: Events;
        start: <T, E = any>(element?: Element | string, model?: T, view?: View<T>, update?: Update<T, E>, options?: AppStartOptions<T>) => Component<T, E>;
        h: (tag: string | Function, props: any, ...children: any[]) => VDOM;
        createElement: (tag: string | Function, props: any, ...children: any[]) => VDOM;
        render: (element: Element | string, node: VDOM, component?: any) => void;
        Fragment: (props: any, ...children: any[]) => any[];
        webComponent: (name: string, componentClass: any, options?: CustomElementOptions) => void;
        safeHTML: (html: string) => any[];
        use_render: (render: (node: any, el: HTMLElement) => void, mode?: 0 | 1) => void;
        use_react: (React: any, ReactDOM: any) => void;
        route: (url: string) => void;
        constructor();
        on(name: string, fn: Function, options?: EventOptions): void;
        off(name: string, fn: Function): void;
        find(name: string): Array<{
            fn: Function;
            options: EventOptions;
        }> | undefined;
        run(name: string, ...args: any[]): number;
        once(name: string, fn: Function, options?: EventOptions): void;
        private delay;
        runAsync(name: string, ...args: any[]): Promise<any[]>;
        query(name: string, ...args: any[]): Promise<any[]>;
        private getSubscribers;
    }
    let app: App;
    export default app;
}
declare module "vdom-my" {
    import { VDOM } from "types";
    export type Element = any;
    export function Fragment(props?: {}, ...children: any[]): any[];
    export function createElement(tag: string | Function | [], props?: {}, ...children: any[]): any;
    export const updateElement: (element: Element, nodes: VDOM, component?: {}) => void;
    export const safeHTML: (html: string) => any[];
    export function updateProps(element: Element, props: Record<string, any>, isSvg: boolean): void;
}
declare module "vdom" {
    import { createElement, updateElement, Fragment, safeHTML } from "vdom-my";
    export { createElement, Fragment, updateElement as render, safeHTML };
    export { createElement as jsx, createElement as jsxs };
}
declare module "router" {
    export type Route = (url: string, ...args: any[]) => any;
    export const ROUTER_EVENT: string;
    export const ROUTER_404_EVENT: string;
    export const route: Route;
    export default route;
}
declare module "apprun" {
    import app, { App } from "app";
    import { Fragment, safeHTML } from "vdom";
    import { Component } from "component";
    import { VNode, View, Action, Update, EventOptions, ActionOptions, MountOptions, AppStartOptions, CustomElementOptions } from "types";
    import { on, update, customElement } from "decorator";
    import { ROUTER_EVENT, ROUTER_404_EVENT } from "router";
    export type StatelessComponent<T = {}> = (args: T) => string | VNode | void;
    export { App, app, Component, View, Action, Update, on, update, EventOptions, ActionOptions, MountOptions, Fragment, safeHTML };
    export { update as event };
    export { ROUTER_EVENT, ROUTER_404_EVENT };
    export { customElement, CustomElementOptions, AppStartOptions };
    export default app;
}
declare module "vdom-lit-html" {
    import { createElement, Fragment } from "vdom-my";
    import { VDOM } from "types";
    import { svg, html } from 'lit-html';
    import { Directive, Part, PartInfo } from 'lit-html/directive.js';
    function _render(element: HTMLElement, vdom: VDOM, parent?: {}): void;
    export class RunDirective extends Directive {
        value: number | undefined;
        constructor(partInfo: PartInfo);
        update(part: Part, params: any): symbol;
        render(): symbol;
    }
    const run: any;
    export { createElement, Fragment, html, svg, _render as render, run };
}
declare module "apprun-html" {
    import app from "apprun";
    export { app, Component, View, Action, Update, on, update, event, EventOptions, customElement, CustomElementOptions, ROUTER_404_EVENT, ROUTER_EVENT, safeHTML } from "apprun";
    import { render, html, svg, run } from "vdom-lit-html";
    export { html, svg, render, run };
    export default app;
}
